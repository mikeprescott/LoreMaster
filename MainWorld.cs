//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Collections;
using System.IO;

namespace Generation {
	public class MainWorld {

		public Seed seed = new Seed();
		public int [,] initialGrid = new int[36,36];
		public int [,] Grid;
		public Biome[] Biomes = new Biome[9];
		public string[] Spells = new String[9];

		public MainWorld( string input) {
			seed.CreateSeed (input);
			GenerateMainWorld ();
			CarveBiomes ();
		}

		private void CarveBiomes (){
			//Go through each spot on the grid,
			// Find each Biome section and record
			// It's location in reference to the
			// world and the biome.
			
			for (int x = 0; x < Grid.GetLength(0); x++) {
				for (int y = 0; y < Grid.GetLength(1); y++) {
					if(Grid[x, y] >= 0){
						Biomes[Grid[x, y]].Sections[Biomes[Grid[x, y]].SectionCounter] = new Section();
						Biomes[Grid[x, y]].Sections[Biomes[Grid[x, y]].SectionCounter].X = x;
						Biomes[Grid[x, y]].Sections[Biomes[Grid[x, y]].SectionCounter].Y = y;
						Biomes[Grid[x, y]].Sections[Biomes[Grid[x, y]].SectionCounter].Biome = Grid[x, y];
						Biomes[Grid[x, y]].Sections[Biomes[Grid[x, y]].SectionCounter].Number = Biomes[Grid[x, y]].SectionCounter;
						Biomes[Grid[x, y]].SectionCounter++;
					}
				}
			}

			//Find them Sections Neighbors!!!
			for (int b = 0; b < Biomes.GetLength(0); b++) {
				for (int s = 0; s < Biomes[b].Sections.GetLength(0); s++) {
					Biomes[b].Sections[s].North = FindNeighbor(Biomes[b].Sections[s].X, Biomes[b].Sections[s].Y - 1);
					Biomes[b].Sections[s].East = FindNeighbor(Biomes[b].Sections[s].X + 1, Biomes[b].Sections[s].Y);
					Biomes[b].Sections[s].South = FindNeighbor(Biomes[b].Sections[s].X, Biomes[b].Sections[s].Y + 1);
					Biomes[b].Sections[s].West = FindNeighbor(Biomes[b].Sections[s].X - 1, Biomes[b].Sections[s].Y);
				}
			}

			//Biome Tile Maps
			for (int b = 0; b < Biomes.GetLength(0); b++) {
				Biomes[b].NeutralizeMap();
				Biomes[b].PlotBorders();
				Biomes[b].PlotGates();

			}

			Debug.Log (Biomes [0].Gates.GetLength (0));
		}

		private Neighbor FindNeighbor(int x, int y){
			Neighbor N = new Neighbor ();
			
			for (int b = 0; b < Biomes.GetLength(0); b++) {
				for (int s = 0; s < Biomes[b].Sections.GetLength(0); s++) {
					if(Biomes[b].Sections[s].X == x && Biomes[b].Sections[s].Y == y){
						N.Biome = Biomes[b].Sections[s].Biome;
						N.Section = Biomes[b].Sections[s].Number;
					}
				}
			}

			return N;
		}

		private void GenerateMainWorld(){
			//Clear out Initial  Grid
			for (int x = 0; x < initialGrid.GetLength(0); x++) {
				for (int y = 0; y < initialGrid.GetLength(1); y++) {
					initialGrid[x, y] = -1;
				}
			}

			//Biome 0 placement
			Biomes [0] = new Biome (0, seed.GetHash());
			
			if (Biomes [0].GetShape () == "Long") {
				initialGrid [15, 15] = 0;
				initialGrid [15, 16] = 0;
				initialGrid [15, 17] = 0;
				initialGrid [15, 18] = 0;
			} else if (Biomes [0].GetShape () == "Tall") {
				initialGrid [15, 15] = 0;
				initialGrid [16, 15] = 0;
				initialGrid [17, 15] = 0;
				initialGrid [18, 15] = 0;
			} else {
				initialGrid [15, 15] = 0;
				initialGrid [15, 16] = 0;
				initialGrid [16, 15] = 0;
				initialGrid [16, 16] = 0;
			}

			//Biome 1 - 8 Placement
			ArrayList xList = new ArrayList();
			ArrayList yList = new ArrayList();
			int spot = 0;
			int spotX = 0;
			int spotY = 0;
			for (int i = 1; i < Biomes.GetLength(0); i ++) {		
				xList.Clear();
				yList.Clear();

				//Biome 1 - 8 placement
				Biomes [i] = new Biome (i, seed.GetHash());
								
				for (int x = 0; x < initialGrid.GetLength(0); x++) {
					for (int y = 0; y < initialGrid.GetLength(1); y++) {
						if(GoodSpot(x, y, Biomes[i])){
							xList.Add(x);
							yList.Add(y);
						}
					}
				}

				if(xList.Count == 0){
					Debug.Log("Biome Unplacable.");
				}else{
					spot = Biomes[i].seed.Ran(xList.Count, 16) - 1;
					spotX = (int)xList[spot];
					spotY = (int)yList[spot];
					PlaceBiome(spotX, spotY, Biomes[i]);
				}
			}

			FinalizeLayout ();
		}

		private void FinalizeLayout(){
			int minX = initialGrid.GetLength (0);
			int maxX = 0;
			int minY = initialGrid.GetLength (1);
			int maxY = 0;
			int newX = maxX;
			int newY = maxY;

			for (int x = 0; x < initialGrid.GetLength(0); x++) {
				for (int y = 0; y < initialGrid.GetLength(1); y++) {
					if(initialGrid[x,y] >= 0){
						if(x < minX){
							minX = x;
						}
						if(y < minY){
							minY = y;
						}
						if(x > maxX){
							maxX = x;
						}
						if(y > maxY){
							maxY = y;
						}
					}
				}
			}
			maxX++;
			maxY++;
			newX = maxX - minX;
			newY = maxY - minY;


			Grid = new int[newX, newY];

			for (int x = minX; x < maxX; x++) {
				for (int y = minY; y < maxY; y++) {
					Grid[x-minX, y-minY] = initialGrid[x,y];
				}
			}
		}

		private void PlaceBiome(int x, int y, Biome MyBiome){
			if (MyBiome.GetShape () == "Long") {
				initialGrid [x, y] = MyBiome.GetDungeonLevel();
				initialGrid [x, y + 1] = MyBiome.GetDungeonLevel();
				initialGrid [x, y + 2] = MyBiome.GetDungeonLevel();
				initialGrid [x, y + 3] = MyBiome.GetDungeonLevel();
			} else if (MyBiome.GetShape () == "Tall") {
				initialGrid [x, y] = MyBiome.GetDungeonLevel();
				initialGrid [x + 1, y] = MyBiome.GetDungeonLevel();
				initialGrid [x + 2, y] = MyBiome.GetDungeonLevel();
				initialGrid [x + 3, y] = MyBiome.GetDungeonLevel();
			} else {
				initialGrid [x, y] = MyBiome.GetDungeonLevel();
				initialGrid [x, y + 1] = MyBiome.GetDungeonLevel();
				initialGrid [x + 1, y] = MyBiome.GetDungeonLevel();
				initialGrid [x + 1, y + 1] = MyBiome.GetDungeonLevel();
			}
		}

		private bool GoodSpot(int x, int y, Biome MyBiome){
			return ( CanFit(x, y, MyBiome) && IsNeighboring(x, y, MyBiome));
		}

		private bool IsNeighboring(int x, int y, Biome MyBiome){
			if (MyBiome.GetShape () == "Long") {
				if( SquareNeighbored(x, y) || SquareNeighbored(x, y + 1) ||	SquareNeighbored(x, y + 2) || SquareNeighbored(x, y + 3)){
					return true;
				}
			} else if (MyBiome.GetShape () == "Tall") {
				if(SquareNeighbored(x, y) || SquareNeighbored(x + 1, y) || SquareNeighbored(x + 2, y) || SquareNeighbored(x + 3, y)){
					return true;
				}
			} else {
				if( SquareNeighbored(x, y) || SquareNeighbored(x, y + 1) || SquareNeighbored(x + 1, y) || SquareNeighbored(x + 1, y + 1)){
					return true;
				}
			}
			
			return false;

		}

		private bool CanFit(int x, int y, Biome BiomeFit ){
			if (BiomeFit.GetShape () == "Long") {
				if( SquareOK(x, y) && SquareOK(x, y + 1) &&	SquareOK(x, y + 2) && SquareOK(x, y + 3)){
					return true;
				}
			} else if (BiomeFit.GetShape () == "Tall") {
				if(SquareOK(x, y) && SquareOK(x + 1, y) && SquareOK(x + 2, y) && SquareOK(x + 3, y)){
					return true;
				}
			} else {
				if( SquareOK(x, y) && SquareOK(x, y + 1) && SquareOK(x + 1, y) && SquareOK(x + 1, y + 1)){
					return true;
				}
			}

			return false;
		}
		
		private bool SquareOK(int x, int y){
			return (x >= 0 && y >= 0 && x < initialGrid.GetLength (0) && y < initialGrid.GetLength (1) && initialGrid [x, y] == -1);
		}

		private bool SquareOccupied(int x, int y){
			return (x >= 0 && y >= 0 && x < initialGrid.GetLength (0) && y < initialGrid.GetLength (1) && initialGrid [x, y] >= 0);
		}

		private bool SquareNeighbored(int x, int y){
			return (SquareOccupied (x - 1, y) || SquareOccupied (x + 1, y) || SquareOccupied (x, y - 1) || SquareOccupied (x, y + 1));
		}

		public void PrintGrid(){
			string sOut = "";
			
			for (int x = 0; x < Grid.GetLength(0); x++) {
				for (int y = 0; y < Grid.GetLength(1); y++) {
					if(Grid[x, y] == -1)
						sOut += "_";
					else
						sOut += Grid[x, y];
				}
				sOut += Environment.NewLine;
			}
			Debug.Log(sOut);
		}
	}
}

